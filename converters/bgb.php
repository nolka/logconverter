<?
/*
Это пример простейшего конвертера логов.
На вход он забирает большой лог-файл за 24 часа, формат CDR записей этого лога соответствует
формату логов BGBilling. 

В Вашем конвертере обязательно должны быть реализованы 2 метода:

** converterDoFile(string filename) - этот метод будет вызван, когда logconv попытается 
подключить указанный ему конвертер через параметр командной строки -c
В качестве имени файла будет передан путь до источника грязных логов.

** function converterGetData() - этот метод должен за 1 вызов возвращать только 1 строчку
CDR из источника грязных логов. По сути, это основной метод, В нем Вы можете читать Ваш 
источник грязых логов в любом формате и приводить его в формат BGBilling.
ОБРАТИТЕ ВНИМАНИЕ НА ТО, что возвращать нужно не строку, а ассоциативный массив вида:
    array(
    'src' => 'здесь возвращается исходная CDR строка полностью',
    'gibs' => array() // сюда необходимо поместить результат функции explode("\t", 'исходная CDR строка')
    );

*/

$fh = null;

// функция, открывающая грязный логфайл на чтение
function converterDoFile($filename)
{
    global $fh;
    $fh = fopen($filename, "r");
    if(false === $fh)
    {
        return false;
    }
    else
    {
        return true;
    }
        
}

// функция, возвращающая данные из грязного лога в виде ассоциативного массива,
// за дополнительной информацией см logconv.php
// здесь осуществляется основная логика по преобразованию данных из грязного лога
// в формат, понятный БГБиллингу
function converterGetData()
{
    global $fh;
    
    // пытаемся получить строчку из грязного лога
    $line = fgets($fh);
    
    if($line === false)
    {
        // если не получили - говорим скрипту что плохи дела
        return false;
    }
    
    // если получили, готовим нашу структуру данных
    $la = explode("\t", $line);

    $res = array();
    // сюда кладем исходную строчку лога
    $res['src'] = $line;
    // сюда кладем массив
    $res['gibs'] = $la;
    // отдаем
    return $res;
}
?> 
